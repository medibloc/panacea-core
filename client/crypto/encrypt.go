package crypto

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"strconv"

	"github.com/btcsuite/btcd/btcec"
	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/crypto/keyring"
	sdk "github.com/cosmos/cosmos-sdk/types"
	datadealkeeper "github.com/medibloc/panacea-core/v2/x/datadeal/keeper"
	oraclekeeper "github.com/medibloc/panacea-core/v2/x/oracle/keeper"
	"github.com/spf13/cobra"
	"github.com/tendermint/tendermint/libs/cli"
)

const (
	FlagCipherText     = "cipher-text"
	FlagCipherTextPath = "path"
)

func Command(defaultNodeHome string) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "encrypt-data [file-path] [key-name] [dealID]",
		Short: "Encrypt the data file with shared key which consists of oracle public key and seller private key.",
		Long: `This command can encrypt data with shared key which consists of oracle public key and seller private key.
				And your key should be stored in the localStore.
				(According to the following command (panacead keys add ...)`,
		Args: cobra.ExactArgs(3),
		RunE: func(cmd *cobra.Command, args []string) error {
			clientCtx := client.GetClientContextFromCmd(cmd)

			dealID, err := strconv.ParseUint(args[2], 10, 64)
			if err != nil {
				return err
			}

			encryptedData, err := Encrypt(clientCtx, cmd, args[0], args[1], dealID)
			if err != nil {
				return err
			}

			cmd.Println(string(encryptedData))

			return nil
		},
	}

	cmd.PersistentFlags().String(flags.FlagHome, defaultNodeHome, "The application home directory")
	cmd.PersistentFlags().String(flags.FlagKeyringDir, "", "The client Keyring directory; if omitted, the default 'home' directory will be used")
	cmd.PersistentFlags().String(flags.FlagKeyringBackend, flags.DefaultKeyringBackend, "Select keyring's backend (os|file|test)")
	cmd.PersistentFlags().String(cli.OutputFlag, "text", "Output format (text|json)")
	cmd.Flags().String(FlagCipherText, "", "Cipher text in the form of a byte array")
	cmd.Flags().String(FlagCipherTextPath, "", "Path to the file where the cipher text in the form of a byte array is stored")

	return cmd
}

func Encrypt(clientCtx client.Context, cmd *cobra.Command, filePath, keyName string, dealID uint64) ([]byte, error) {
	privKeyHex, err := keyring.NewUnsafe(clientCtx.Keyring).UnsafeExportPrivKeyHex(keyName)
	if err != nil {
		return nil, err
	}

	privKeyBz, err := hex.DecodeString(privKeyHex)
	if err != nil {
		return nil, err
	}

	sellerPrivKey, _ := btcec.PrivKeyFromBytes(btcec.S256(), privKeyBz)

	ctx := sdk.UnwrapSDKContext(cmd.Context())
	params := oraclekeeper.Keeper{}.GetParams(ctx)

	pubKeybz, err := base64.StdEncoding.DecodeString(params.OraclePublicKey)
	if err != nil {
		return nil, err
	}

	oraclePubkey, err := btcec.ParsePubKey(pubKeybz, btcec.S256())
	if err != nil {
		return nil, err
	}

	sharedKey := deriveSharedKey(sellerPrivKey, oraclePubkey, KDFSHA256)

	originData, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	deal, err := datadealkeeper.Keeper{}.GetDeal(ctx, dealID)
	if err != nil {
		return nil, err
	}

	encryptedData, err := EncryptWithAES256(sharedKey, deal.Nonce, originData)
	if err != nil {
		return nil, err
	}

	return encryptedData, nil
}

// deriveSharedKey derives a shared key (which can be used for asymmetric encryption)
// using a specified KDF (Key Derivation Function)
// from a shared secret generated by Diffie-Hellman key exchange (ECDH).
func deriveSharedKey(priv *btcec.PrivateKey, pub *btcec.PublicKey, kdf func([]byte) []byte) []byte {
	sharedSecret := btcec.GenerateSharedSecret(priv, pub)
	return kdf(sharedSecret)
}

// KDFSHA256 is a key derivation function which uses SHA256.
func KDFSHA256(in []byte) []byte {
	out := sha256.Sum256(in)
	return out[:]
}

// EncryptWithAES256 decrypts data using a AES256 cryptography.
func EncryptWithAES256(secretKey, nonce, data []byte) ([]byte, error) {
	if len(secretKey) != 32 {
		return nil, fmt.Errorf("secret key is not for AES-256: total %d bits", 8*len(secretKey))
	}

	block, err := aes.NewCipher(secretKey)
	if err != nil {
		return nil, err
	}

	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	if len(nonce) != aesgcm.NonceSize() {
		return nil, fmt.Errorf("nonce length must be %v", aesgcm.NonceSize())
	}

	cipherText := aesgcm.Seal(nil, nonce, data, nil)

	return cipherText, nil
}
